#!/usr/bin/env ruby
# frozen_string_literal: true
require 'csi'
require 'optparse'
require 'timeout'
require 'pty'
require 'ruby-audio'
require 'fftw3'

opts = {}
OptionParser.new do |options|
  options.banner = "USAGE:
    #{$PROGRAM_NAME} [opts]
  "

  options.on('-fFROM', '--from=FROM', '<Required - Dial Range from (Beginning Number)>') do |f|
    opts[:from_num] = f
  end

  options.on('-tTO', '--to=TO', '<Required - Dial Range to (Ending Number)>') do |t|
    opts[:to_num] = t
  end

  options.on('-sSEC', '--seconds-to-record=SEC', '<Required - Senconds to Record >') do |s|
    opts[:seconds_to_record] = s
  end

  options.on('-aADB', '--adb-path=ADB', '<Required - Path to ADB (Android Debug Bridge)>') do |adb|
    opts[:adb_bin] = adb
  end

  options.on('-SSOX', '--sox-path=SOX', '<Required - Path to SoX Binary, the Swiss Army knife of Audio>') do |sox|
    opts[:sox_bin] = sox
  end

  options.on('-wWAV', '--wav-archive-dir=WAV', '<Required - Path to Directory to Store WAV Files>') do |wav|
    opts[:wav_archive] = wav
  end

  options.on('-r', '--[no-]randomize', '<Optional - Randomize Number Range>') do |r|
    opts[:randomize] = r
  end

  options.on('-pRES', '--results-path=RES', '<Optional - Path to Save SQLite Database Results>') do |p|
    opts[:results_path] = p
  end
end.parse!

if opts.empty?
  puts `#{$PROGRAM_NAME} --help`
  exit 1
end

from_num = opts[:from_num].to_s.scrub.strip.chomp.delete('-').delete('.').delete('+').to_i
to_num = opts[:to_num].to_s.scrub.strip.chomp.delete('-').delete('.').delete('+').to_i
randomize = opts[:randomize]

adb_bin = opts[:adb_bin] if File.exists?(opts[:adb_bin].to_s.scrub.strip.chomp)

sox_bin = opts[:sox_bin] if File.exists?(opts[:sox_bin].to_s.scrub.strip.chomp)
wav_archive = opts[:wav_archive].to_s.scrub.strip.chomp if Dir.exists?(opts[:wav_archive].to_s.scrub.strip.chomp)

seconds_to_record = opts[:seconds_to_record].to_i

if from_num <= to_num
  range = []
  wav_files_arr = []
  # Prepare the targets for assessment
  (from_num..to_num).each { |number| range.push(number) }

  # Randomize targets if applicable
  range.shuffle! if randomize

  range.each do |target_num|
    start_timestamp = Time.now.strftime('%Y-%m-%d.%H.%M.%S')
    print "*** #{start_timestamp} => dialing #{target_num}..."
    CSI::Plugins::Android.adb_sh(
      adb_path: adb_bin,
      command: "am start -a android.intent.action.CALL -d tel:'#{target_num}'"
    )

    # Record Call
    pid_to_kill = 0
    wav_file = "#{wav_archive}/#{target_num}-#{start_timestamp}.wav"
    sox_cmd = "#{sox_bin} -d #{wav_file}"

    begin
      print "recording audio for #{seconds_to_record} seconds..."
      Timeout::timeout(seconds_to_record) do
        PTY.spawn(sox_cmd) do |stdout, _stdin, pid|
          pid_to_kill = pid
          stdout.sync = true
          stdout.each { |line| puts line }
        end
      end
    rescue Timeout::Error
      Process.kill('KILL', pid_to_kill)
      print 'recording complete...'
    end
 

    print 'hanging up...'
    CSI::Plugins::Android.adb_sh(
      adb_path: adb_bin,
      command: 'input keyevent KEYCODE_ENDCALL'
    )

    # Add our newly created wav file path for FFT post-processing
    wav_files_arr.push(wav_file)

    puts 'complete.'
  end

  # TODO: Post Process Audio Files into FFT Plots & Save to SQLite DB for Later Signature Analysis
  wav_files_arr.each do |wav_file|
    print "\n*** FFT enumeration => #{wav_file}..."
    window_size = 1024
    wf_arr = []
    fft = Array.new(window_size/2,[])
    begin
      buf = RubyAudio::Buffer.float(window_size)
      RubyAudio::Sound.open(wav_file) do |snd|
        while snd.read(buf) != 0
          wf_arr.concat(buf.to_a)
          na = NArray.to_na(buf.to_a)
          fft_slice = FFTW3.fft(na).to_a[0, window_size/2]
          j=0
          fft_slice.each { |x| fft[j] << x; j+=1 }
        end
      end
      # puts fft # doing a puts on fft is like, holy omg.
      puts "complete."
    rescue => err
      log.error "error reading audio file: " + err
      exit
    end
  end
else
  puts "ERROR: 'from' parameter must be less than 'to' parameter\n#{`#{$PROGRAM_NAME} --help`}"
end
