#!/usr/bin/env ruby
# frozen_string_literal: true
require 'csi'
require 'optparse'
require 'ruby-audio'
#require 'fftw3'

opts = {}
OptionParser.new do |options|
  options.banner = "USAGE:
    #{$PROGRAM_NAME} [opts]
  "

  options.on('-fFROM', '--from=FROM', '<Required - Dial Range From (Beginning Number)>') do |f|
    opts[:from_num] = f
  end

  options.on('-tTO', '--to=TO', '<Required - Dial Range To (Ending Number)>') do |t|
    opts[:to_num] = t
  end

  options.on('-sSEC', '--seconds-to-record=SEC', '<Required - Senconds to Record >') do |s|
    opts[:seconds_to_record] = s
  end

  options.on('-r', '--[no-]randomize', '<Optional - Randomize Number Range>') do |r|
    opts[:randomize] = r
  end

  options.on('-pRES', '--results-path=RES', '<Optional - Path to Save SQLite Database Results>') do |p|
    opts[:results_path] = p
  end
end.parse!

if opts.empty?
  puts `#{$PROGRAM_NAME} --help`
  exit 1
end

from_num = opts[:from_num].to_s.scrub.strip.chomp.delete('-').delete('.').delete('+').to_i
to_num = opts[:to_num].to_s.scrub.strip.chomp.delete('-').delete('.').delete('+').to_i
randomize = opts[:randomize]

seconds_to_record = opts[:seconds_to_record].to_i

if from_num <= to_num
  range = []
  # Prepare the targets for assessment
  (from_num..to_num).each { |number| range.push(number) }

  # Randomize targets if applicable
  range.shuffle! if randomize

  range.each do |target_num|
    print "Dialing #{target_num}..."
    CSI::Plugins::Android.adb_sh(
      adb_path: '/usr/local/bin/adb',
      command: "am start -a android.intent.action.CALL -d tel:'#{target_num}'"
    )

    sleep seconds_to_record 
    # TODO: Record Call

    print 'terminating call...'
    CSI::Plugins::Android.adb_sh(
      adb_path: '/usr/local/bin/adb',
      command: 'input keyevent KEYCODE_ENDCALL'
    )
    puts 'complete.'
  end
  # TODO: Post Process Audio Files into FFT Plots for Signature Analysis & Save to SQLite DB
  # Pseudo-code
  # wav_files.each do |fname|
  #   window_size = 1024
  #   wave = Array.new
  #   fft = Array.new(window_size/2,[])
  #   begin
  #     buf = RubyAudio::Buffer.float(window_size)
  #     RubyAudio::Sound.open(fname) do |snd|
  #       while snd.read(buf) != 0
  #         wave.concat(buf.to_a)
  #         na = NArray.to_na(buf.to_a)
  #         fft_slice = FFTW3.fft(na).to_a[0, window_size/2]
  #         j=0
  #         fft_slice.each { |x| fft[j] << x; j+=1 }
  #       end
  #     end
  #   rescue => err
  #     log.error "error reading audio file: " + err
  #     exit
  #   end
  # end
else
  puts "ERROR: 'from' parameter must be less than 'to' parameter\n#{`#{$PROGRAM_NAME} --help`}"
end
