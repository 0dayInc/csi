#!/usr/bin/env ruby
# frozen_string_literal: true
require 'csi'
require 'optparse'
require 'timeout'
require 'pty'
# require 'ruby-audio'
require 'wavefile'
require 'fftw3'
require 'fastercsv'

opts = {}
OptionParser.new do |options|
  options.banner = "USAGE:
    #{$PROGRAM_NAME} [opts]
  "

  options.on('-fFROM', '--from=FROM', '<Required - Dial Range from (Beginning Number)>') do |f|
    opts[:from_num] = f
  end

  options.on('-tTO', '--to=TO', '<Required - Dial Range to (Ending Number)>') do |t|
    opts[:to_num] = t
  end

  options.on('-sSEC', '--seconds-to-record=SEC', '<Required - Senconds to Record >') do |s|
    opts[:seconds_to_record] = s
  end

  options.on('-aADB', '--adb-path=ADB', '<Required - Path to ADB (Android Debug Bridge)>') do |adb|
    opts[:adb_bin] = adb
  end

  options.on('-SSOX', '--sox-path=SOX', '<Required - Path to SoX Binary, the Swiss Army knife of Audio>') do |sox|
    opts[:sox_bin] = sox
  end

  options.on('-wWAV', '--wav-archive-dir=WAV', '<Required - Path to Directory to Store WAV Files>') do |wav|
    opts[:wav_archive] = wav
  end

  options.on('-r', '--[no-]randomize', '<Optional - Randomize Number Range>') do |r|
    opts[:randomize] = r
  end

  options.on('-pRES', '--results-path=RES', '<Optional - Path to Save SQLite Database Results>') do |p|
    opts[:results_path] = p
  end
end.parse!

if opts.empty?
  puts `#{$PROGRAM_NAME} --help`
  exit 1
end

from_num = opts[:from_num].to_s.scrub.strip.chomp.delete('-').delete('.').delete('+').to_i
to_num = opts[:to_num].to_s.scrub.strip.chomp.delete('-').delete('.').delete('+').to_i
randomize = opts[:randomize]

adb_bin = opts[:adb_bin] if File.exist?(opts[:adb_bin].to_s.scrub.strip.chomp)

sox_bin = opts[:sox_bin] if File.exist?(opts[:sox_bin].to_s.scrub.strip.chomp)
wav_archive = opts[:wav_archive].to_s.scrub.strip.chomp if Dir.exist?(opts[:wav_archive].to_s.scrub.strip.chomp)

seconds_to_record = opts[:seconds_to_record].to_i

if from_num <= to_num
  range = []
  wav_files_arr = []
  # Prepare the targets for assessment
  (from_num..to_num).each { |number| range.push(number) }

  # Randomize targets if applicable
  range.shuffle! if randomize

  range.each do |target_num|
    start_timestamp = Time.now.strftime('%Y-%m-%d.%H.%M.%S')
    print "*** #{start_timestamp} => dialing #{target_num}..."
    CSI::Plugins::Android.adb_sh(
      adb_path: adb_bin,
      command: "am start -a android.intent.action.CALL -d tel:'#{target_num}'"
    )

    # Record Call
    pid_to_kill = 0
    wav_file = "#{wav_archive}/#{target_num}-#{start_timestamp}.wav"
    sox_cmd = "#{sox_bin} -d #{wav_file}"

    begin
      print "recording audio for #{seconds_to_record} seconds..."
      Timeout.timeout(seconds_to_record) do
        PTY.spawn(sox_cmd) do |stdout, _stdin, pid|
          pid_to_kill = pid
          stdout.sync = true
          stdout.each { |line| puts line }
        end
      end
    rescue Timeout::Error
      Process.kill('KILL', pid_to_kill)
      print 'recording complete...'
    end

    print 'hanging up...'
    CSI::Plugins::Android.adb_sh(
      adb_path: adb_bin,
      command: 'input keyevent KEYCODE_ENDCALL'
    )

    # Add our newly created wav file path for FFT post-processing
    wav_files_arr.push(wav_file)

    puts 'complete.'
  end

  # TODO: Post Process Audio Files into FFT Plots & Save to SQLite DB for Later Signature Analysis
  wav_files_arr.each do |wav_file|
    print "\n*** FFT enumeration => #{wav_file}..."
    # window_size = 1024
    # wf_arr = []
    # fft = Array.new(window_size / 2, [])
    # begin
    #   buf = RubyAudio::Buffer.float(window_size)
    #   RubyAudio::Sound.open(wav_file) do |snd|
    #     while snd.read(buf) != 0
    #       wf_arr.concat(buf.to_a)
    #       na = NArray.to_na(buf.to_a)
    #       fft_slice = FFTW3.fft(na).to_a[0, window_size / 2]
    #       j = 0
    #       fft_slice.each do |x|
    #         fft[j] << x
    #         j += 1
    #       end
    #     end
    #   end
    #   puts fft.class
    #   # File.open("#{wav_file}.fft.dat", 'w') do |f|
    #   #   f.puts fft
    #   # end
    #   puts 'complete.'
    # rescue => e
    #   raise e.message
    # end
    fft_wav = WaveFile.open(wav_file)

    samples = fft_wav.sample_data[0, [fft_wav.sample_rate * 10, fft_wav.sample_data.size].min]
    duration = samples.size / fft_wav.sample_rate

    na = NArray.float(2, samples.size)
    samples.each_with_index do |v, i|
      na[0, i - 1] = i.to_f / fft_wav.sample_rate.to_f
      na[1, i - 1] = v
    end

    fa = FFTW3.fft(na)
    fa = fa.real.abs # you probably need absolute values for magnitudes of a frequency to make sense

    FasterCSV.open("#{wav_file}.fft.csv", 'w') do |csv|
      0.upto((fa.total / fa.dim) - 1) do |i|
        csv << fa[true, i].to_a
      end
    end
    puts 'complete.'
  end
else
  puts "ERROR: 'from' parameter must be less than 'to' parameter\n#{`#{$PROGRAM_NAME} --help`}"
end
