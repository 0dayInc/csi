#!/usr/bin/env ruby
# frozen_string_literal: true
require 'csi'
require 'optparse'
require 'timeout'
require 'pty'

opts = {}
OptionParser.new do |options|
  options.banner = "USAGE:
    #{$PROGRAM_NAME} [opts]
  "

  options.on('-fFROM', '--from=FROM', '<Required - Dial Range from (Beginning Number)>') do |f|
    opts[:from_num] = f
  end

  options.on('-tTO', '--to=TO', '<Required - Dial Range to (Ending Number)>') do |t|
    opts[:to_num] = t
  end

  options.on('-sSEC', '--seconds-to-record=SEC', '<Required - Senconds to Record >') do |s|
    opts[:seconds_to_record] = s
  end

  options.on('-aADB', '--adb-path=ADB', '<Required - Path to ADB (Android Debug Bridge)>') do |adb|
    opts[:adb_bin] = adb
  end

  options.on('-SSOX', '--sox-path=SOX', '<Required - Path to SoX Binary, the Swiss Army knife of Audio>') do |sox|
    opts[:sox_bin] = sox
  end

  options.on('-wWAV', '--wav-archive-dir=WAV', '<Required - Path to Directory to Store WAV Files>') do |wav|
    opts[:wav_archive] = wav
  end

  options.on('-r', '--[no-]randomize', '<Optional - Randomize Number Range>') do |r|
    opts[:randomize] = r
  end

  options.on('-pRES', '--results-path=RES', '<Optional - Path to Save SQLite Database Results>') do |p|
    opts[:results_path] = p
  end
end.parse!

if opts.empty?
  puts `#{$PROGRAM_NAME} --help`
  exit 1
end

from_num = opts[:from_num].to_s.scrub.strip.chomp.delete('-').delete('.').delete('+').to_i
to_num = opts[:to_num].to_s.scrub.strip.chomp.delete('-').delete('.').delete('+').to_i
randomize = opts[:randomize]

adb_bin = opts[:adb_bin] if File.exist?(opts[:adb_bin].to_s.scrub.strip.chomp)

sox_bin = opts[:sox_bin] if File.exist?(opts[:sox_bin].to_s.scrub.strip.chomp)
wav_archive = opts[:wav_archive].to_s.scrub.strip.chomp if Dir.exist?(opts[:wav_archive].to_s.scrub.strip.chomp)

seconds_to_record = opts[:seconds_to_record].to_i

if from_num <= to_num
  begin
    range = []
    # Prepare the targets for assessment
    (from_num..to_num).each { |number| range.push(number) }

    # Randomize targets if applicable
    range.shuffle! if randomize

    range.each do |target_num|
      start_timestamp = Time.now.strftime('%Y-%m-%d.%H.%M.%S')
      puts "*** #{start_timestamp} => dialing #{target_num}:"
      CSI::Plugins::Android.adb_sh(
        adb_path: adb_bin,
        command: "am start -a android.intent.action.CALL -d tel:'#{target_num}'"
      )

      # Record Call
      pid_to_kill = 0
      wav_file = "#{wav_archive}/#{target_num}-#{start_timestamp}.wav"
      sox_cmd = "#{sox_bin} -d #{wav_file}"

      begin
        puts "\trecording audio for #{seconds_to_record} seconds..."
        Timeout.timeout(seconds_to_record) do
          PTY.spawn(sox_cmd) do |stdout, _stdin, pid|
            pid_to_kill = pid
            stdout.sync = true
            stdout.each { |line| puts "\t\t#{line}" }
          end
        end
      rescue Timeout::Error
        Process.kill('KILL', pid_to_kill)
        print 'generating spectrogram...'
        system("#{sox_bin} #{wav_file} -n spectrogram -o #{wav_file}-spectrogram.png -d #{seconds_to_record}")
        puts 'complete.'
      end

      print 'hanging up...'
      CSI::Plugins::Android.adb_sh(
        adb_path: adb_bin,
        command: 'input keyevent KEYCODE_ENDCALL'
      )

      puts "complete.\n\n\n"
    end
  rescue => e
    raise e.message
  ensure
    CSI::Plugins::Android.adb_sh(
      adb_path: adb_bin,
      command: 'input keyevent KEYCODE_ENDCALL'
    )
  end
else
  puts "ERROR: 'from' parameter must be less than 'to' parameter\n#{`#{$PROGRAM_NAME} --help`}"
end
