#!/usr/bin/env ruby
# frozen_string_literal: true

require 'csi'
require 'optparse'

opts = {}
OptionParser.new do |options|
  options.banner = "USAGE:
    #{$PROGRAM_NAME} [opts]
  "

  options.on('-tDOMAINS', '--targets=DOMAINS', '<Required - Comma-Delimited List of Target Domains>') do |t|
    opts[:targets] = t
  end

  options.on('-dDIR', '--output-dir=DIR', '<Required - Directory to Save Results>') do |d|
    opts[:output_dir] = d
  end

  options.on('-eEXCLUDE', '--exclude-domains=EXCLUDE', '<Optional - Comma-Delimited List of Domains to Exclude>') do |e|
    opts[:exclude_domains] = e
  end

  options.on('-sSUBLIST3R', '--sublist3r-path=SUBLIST3R', '<Optional - Path to Sublist3r>') do |s|
    opts[:sublist3r_path] = s
  end

  options.on('-nNMAP', '--nmap-path=NMAP', '<Optional - Path to Nmap>') do |n|
    opts[:nmap_path] = n
  end

  options.on('-bBURP', '--burp-path=BURP', '<Optional - Path to Burp>') do |b|
    opts[:burp_path] = b
  end

  # TODO: Add resume flag/feature
end.parse!

if opts.empty?
  puts `#{$PROGRAM_NAME} --help`
  exit 1
end

# Colors!
red = "\e[31m"
green = "\e[32m"
yellow = "\e[33m"
end_of_color = "\e[0m"

# Required Flag Variables
targets = opts[:targets].to_s.scrub.strip.chomp.delete("\s").split(',')
output_dir = opts[:output_dir].to_s.scrub.strip.chomp if Dir.exist?(opts[:output_dir].to_s.scrub.strip.chomp)
target_domains = "#{output_dir}/target_domains-#{runtime_timestamp}.txt"
File.open(target_domains, 'w') do |f|
  targets.each do |target|
    f.puts target
  end
end

exclude_domains = opts[:exclude_domains].to_s.scrub.strip.chomp.delete("\s").split(',')
sublist3r_path = opts[:sublist3r_path].to_s.scrub.strip.chomp
burp_path = opts[:burp_path].to_s.scrub.strip.chomp
nmap_path = opts[:nmap_path].to_s.scrub.strip.chomp

runtime_timestamp = Time.now.strftime('%Y-%m-%d-%H-%M-%S')

# Run Sublist3r to find as many domains as possible for a given FQDN
unless sublist3r_path.nil?
  sublist3r_target_domains_arr = []
  File.readlines(target_domains).uniq.each do |line|
    sublist3r_target = line.to_s.scrub.strip.chomp
    sublist3r_results = "#{output_dir}/#{sublist3r_target}-#{runtime_timestamp}-sublist3r.txt"
    print "#{green}Sublist3r Domain Discovery #{sublist3r_target}...#{end_of_color}"
    puts `python #{sublist3r_path} -v -d #{sublist3r_target} -o #{sublist3r_results}`
    File.readlines(sublist3r_results).uniq.each do |line|
      discovered_domain = line.to_s.scrub.strip.chomp
      sublist3r_target_domains_arr.push(discovered_domain)
    end
    puts "#{green}complete.#{end_of_color}"
  end
  File.open(target_domains, 'a') do |f|
    sublist3r_target_domains_arr.uniq do |discovered_domain|
      f.puts discovered_domain unless exclude_domains.include?(discovered_domain)
    end
  end
end

unless nmap_path.nil?
  print "#{green}Nmap all the things...#{end_of_color}"
  File.readlines(target_domains).uniq.each do |line|
    nmap_target = line.to_s.scrub.strip.chomp
    next if exclude_domains.include?(nmap_target)
    begin
      nmap_xml_results = "#{output_dir}/#{nmap_target}-#{runtime_timestamp}-nmap_default.xml"
      nmap_targets_arr.push(nmap_target) unless exclude_domains.include?(nmap_target)

      CSI::Plugins::NmapIt.port_scan do |nmap|
        nmap.connect_scan = true
        nmap.service_scan = true
        nmap.verbose = true
        nmap.targets = nmap_target
        nmap.xml = nmap_xml_results
      end

      CSI::Plugins::NmapIt.parse_xml_results(xml_file: nmap_xml_results) do |xml|
        xml.each_host do |host|
          puts "#{green}#{host.hostname}#{end_of_color}"

          host.scripts.each do |_name, output|
            output.each_line { |line| puts line }
          end

          host.each_port do |port|
            puts "#{yellow}#{port.protocol}|#{port.number}|#{port.service}|#{port.state}|#{port.reason}#{end_of_color}"

            port.scripts.each do |name, output|
              puts name
              output.each_line { |line| puts line }
            end
          end
        end
      end
    rescue => e
      puts "#{red}#{e}#{end_of_color}"
      next
    end
  end
  puts "#{green}complete.#{end_of_color}"
end

# TODO: make smarter based on nmap results instead of just https
unless burp_path.nil?
  File.readlines(target_domains).uniq.each do |line|
    burp_obj = CSI::Plugins::BurpSuite.start(
      burp_jar_path: burp_path,
      browser_type: :chrome
    )

    CSI::Plugins::BurpSuite.disable_proxy(
      burp_obj: burp_obj
    )

    browser_obj = burp_obj[:burp_browser]

    burp_target = line.to_s.scrub.strip.chomp
    next if exclude_domains.include?(burp_target)
    begin
      puts "#{green}Navigating to: #{burp_target}#{end_of_color}"
      browser_obj.goto("https://#{burp_target}")

      print "#{green}Invoking Active Scan...#{end_of_color}"
      json_scan_queue = CSI::Plugins::BurpSuite.invoke_active_scan(
        burp_obj: burp_obj,
        target_url: "https://#{burp_target}"
      )
      puts "#{green}complete.#{end_of_color}"

      json_scan_issues = CSI::Plugins::BurpSuite.get_scan_issues(
        burp_obj: burp_obj
      )
      File.open("#{output_dir}/#{target_domains}-#{runtime_timestamp}-burpsuite_activescan.json", 'w') do |f|
        f.puts json_scan_issues
      end

      puts "#{yellow}Burp Suite JSON Results:#{end_of_color}"
      puts "#{red}json_scan_issues#{end_of_color}"

      print "#{green}Generating Burp Suite Active Scan HTML Results...#{end_of_color}"
      CSI::Plugins::BurpSuite.generate_scan_report(
        burp_obj: burp_obj,
        report_type: :html,
        output_path: "#{output_dir}/#{target_domains}-#{runtime_timestamp}-burpsuite_activescan.html"
      )

      browser_obj = CSI::Plugins::TransparentBrowser.close(browser_obj: browser_obj)
      burp_obj = CSI::Plugins::BurpSuite.stop(burp_obj: burp_obj)
    rescue => e
      puts "#{red}#{e}#{end_of_color}"
      next
    end
    puts "#{green}complete.#{end_of_color}\n\n\n"
  end
end
