#!/usr/bin/env ruby
# frozen_string_literal: true
require 'csi'
require 'optparse'
require 'anemone'

opts = {}
OptionParser.new do |options|
  options.banner = "USAGE:
    #{$PROGRAM_NAME} [opts]
  "

  options.on('-tURL', '--target-url=URL', '<Required - URL to Target>') do |t|
    opts[:target_url] = t
  end

  options.on('-dDIR', '--output-dir=DIR', '<Required - Directory to Save Results>') do |d|
    opts[:output_dir] = d
  end

  options.on('-pPROXY', '--proxy=PROXY', '<Optional - HTTP or Socks Proxy>') do |p|
    opts[:proxy] = p
  end

  options.on('-T', '--[no-]with-tor', '<Optional - Proxy w/ TOR (Defaults to false)>') do |w|
    opts[:with_tor] = w
  end

  options.on('-S', '--[no-]spider-fqdn', '<Optional - Spider Target FQDN  (Defaults to true)>') do |s|
    opts[:spider] = s
  end
end.parse!

if opts.empty?
  puts `#{$PROGRAM_NAME} --help`
  exit 1
end

# Required Flag Variables
target_url = opts[:target_url].to_s.scrub.strip.chomp
output_dir = opts[:output_dir].to_s.scrub.strip.chomp if Dir.exist?(opts[:output_dir].to_s.scrub.strip.chomp)

proxy = opts[:proxy].to_s.scrub.strip.chomp unless opts[:proxy].nil?
with_tor = opts[:with_tor]

if opts[:spider]
  spider = false
else
  spider = true
end

spider_results = "#{output_dir}/#{File.basename($PROGRAM_NAME)}.spider"

# Colors!
@dark_red = "\e[1m\e[31m"
@green = "\e[32m"
@yellow = "\e[33m"
@end_of_color = "\e[0m"

begin
  def get_web_cache_deception(opts = {})
    browser_obj = opts[:browser_obj]
    target_url = opts[:target_url].to_s.scrub.chomp.strip
    payload = opts[:payload].to_s.scrub.chomp.strip

    web_cache_deception_url = "#{target_url.chomp('/')}/wcd.#{payload}"
    response = browser_obj.execute(
      method: :get,
      url: web_cache_deception_url,
      verify_ssl: false
    )
    if response.code == 200 && !target_url.include?('?')
      wcd_url_response_length = response.body.length

      # Browse to original page to compare response lengths
      response = browser_obj.execute(
        method: :get,
        url: target_url,
        verify_ssl: false
      )
      orig_url_response_length = response.body.length

      if orig_url_response_length == wcd_url_response_length
        puts "\n#{@dark_red}Potential Candidate: #{web_cache_deception_url}#{@end_of_color}\n"
      else
        print "#{@yellow}.#{@end_of_color}"
      end
    elsif target_url.include?('?')
      stripped_target_url = URI.parse(target_url)
      # Remove query paramters from url
      stripped_target_url.fragment = stripped_target_url.query = nil

      response = browser_obj.execute(
        method: :get,
        url: stripped_target_url.to_s,
        verify_ssl: false
      )
      stripped_url_response_length = response.body.length

      if stripped_url_response_length == orig_url_response_length
        web_cache_deception_url = "#{stripped_target_url.chomp('/')}/wcd.#{payload}"
        response = browser_obj.execute(
          method: :get,
          url: web_cache_deception_url,
          verify_ssl: false
        )
        wcd_url_response_length = response.body.length

        if stripped_url_response_length == wcd_url_response_length
          puts "\n#{@dark_red}Potential Candidate: #{web_cache_deception_url}#{@end_of_color}\n"
        else
          print "#{@yellow}.#{@end_of_color}"
        end

      else
        print "#{@yellow}.#{@end_of_color}"
      end
    else
      print "#{@yellow}.#{@end_of_color}"
    end
  rescue RestClient::InternalServerError => ise
    puts "\n#{@dark_red}#{ise}: #{web_cache_deception_url}#{@end_of_color}\n"
  rescue RestClient::ExceptionWithResponse => ewr
    # puts "#{@yellow}#{er}: #{web_cache_deception_url}#{@end_of_color}"
    print "#{@yellow}.#{@end_of_color}"
  rescue => e
    raise e
  end

  if proxy
    if with_tor
      browser_obj = CSI::Plugins::TransparentBrowser.open(
        browser_type: :rest,
        proxy: proxy,
        with_tor: true
      )::Request
    else
      browser_obj = CSI::Plugins::TransparentBrowser.open(
        browser_type: :rest,
        proxy: proxy
      )::Request
    end
  else
    browser_obj = CSI::Plugins::TransparentBrowser.open(browser_type: :rest)::Request
  end

  if spider
    puts "#{@dark_red}Spidering Target FQDN: #{target_url}#{@end_of_color}"
    File.open(spider_results, 'w') do |f|
      Anemone.crawl(target_url) do |anemone|
        anemone.on_every_page do |page|
          puts "#{@yellow}Discovered: #{page.url}#{@end_of_color}"
          f.puts(page.url)
        end
      end
    end
  end

  web_cache_deception_payload_arr = %w(
    aif aiff au avi bin bmp cab carb cct cdf class css doc dcr dtd gcf gff gif grv hdml hqx ico ini jpeg jpg js mov mp3 mp4 nc pct ppc pws swa swf txt vbs w32 wav wbmp wml wmlc wmls wmlsc xsd zip
  )
  web_cache_deception_payload_arr.each do |payload|
    if spider
      File.readlines(spider_results).uniq.each do |this_page|
        get_web_cache_deception(browser_obj: browser_obj, target_url: this_page, payload: payload)
      end
    else
      get_web_cache_deception(browser_obj: browser_obj, target_url: target_url, payload: payload)
    end
  end
rescue => e
  raise e
ensure
  browser_obj = CSI::Plugins::TransparentBrowser.close(browser_obj: browser_obj) unless browser_obj.nil?
end
