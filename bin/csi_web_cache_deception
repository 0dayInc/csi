#!/usr/bin/env ruby
# frozen_string_literal: true
require 'csi'
require 'optparse'
require 'anemone'

opts = {}
OptionParser.new do |options|
  options.banner = "USAGE:
    #{$PROGRAM_NAME} [opts]
  "

  options.on('-tURL', '--target-url=URL', '<Required - URL to Target>') do |t|
    opts[:target_url] = t
  end

  options.on('-dDIR', '--output-dir=DIR', '<Required - Directory to Save Results>') do |d|
    opts[:output_dir] = d
  end

  options.on('-pPROXY', '--proxy=PROXY', '<Optional - HTTP or Socks Proxy>') do |p|
    opts[:proxy] = p
  end

  options.on('-T', '--[no-]with-tor', '<Optional - Proxy w/ TOR (Defaults to false)>') do |w|
    opts[:with_tor] = w
  end

  options.on('-S', '--[no-]spider-fqdn', '<Optional - Spider Target FQDN  (Defaults to true)>') do |s|
    opts[:spider] = s
  end
end.parse!

if opts.empty?
  puts `#{$PROGRAM_NAME} --help`
  exit 1
end

# Required Flag Variables
target_url = opts[:target_url].to_s.scrub.strip.chomp
output_dir = opts[:output_dir].to_s.scrub.strip.chomp if Dir.exist?(opts[:output_dir].to_s.scrub.strip.chomp)

proxy = opts[:proxy].to_s.scrub.strip.chomp unless opts[:proxy].nil?
with_tor = opts[:with_tor]

if opts[:spider]
  spider = false
else
  spider = true
end

spider_results = "#{output_dir}/#{File.basename($PROGRAM_NAME)}.spider"
output_results = "#{output_dir}/#{File.basename($PROGRAM_NAME)}.results"

# Colors!
@dark_red = "\e[1m\e[31m"
@green = "\e[32m"
@yellow = "\e[33m"
@end_of_color = "\e[0m"

begin
  def get_web_cache_deception(opts = {})
    browser_obj = opts[:browser_obj]
    target_url = opts[:target_url].to_s.scrub.chomp.strip
    payload = opts[:payload].to_s.scrub.chomp.strip

    # Browse to original page to compare response lengths
    response = browser_obj.execute(
      method: :get,
      url: target_url,
      user_agent: 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36',
      max_redirects: 0,
      verify_ssl: false
    )
    orig_url_response_length = response.body.length

    web_cache_deception_url = "#{target_url.chomp('/')}/wcd.#{payload}"
    response = browser_obj.execute(
      method: :get,
      url: web_cache_deception_url,
      user_agent: 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36',
      max_redirects: 0,
      verify_ssl: false
    )
    wcd_url_response_length = response.body.length

    if response.code == 200 && !target_url.include?('?')
      if orig_url_response_length == wcd_url_response_length
        puts "\n#{@dark_red}Alert! Potential Candidate: #{web_cache_deception_url}#{@end_of_color}\n"
        return "Alert! Potential Candidate: #{web_cache_deception_url}"
      else
        print "#{@yellow}.#{@end_of_color}"
        return "Response Length Mismatch: HTTP #{response.code} | Orig Len: #{orig_url_response_length} | WCD Len: #{wcd_url_response_length} | WCD: #{web_cache_deception_url}"
      end
    elsif response.code == 200 && target_url.include?('?')
      stripped_target_url = URI.parse(target_url)
      # Remove query paramters from url
      stripped_target_url.fragment = stripped_target_url.query = nil

      response = browser_obj.execute(
        method: :get,
        url: stripped_target_url.to_s,
        user_agent: 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36',
        max_redirects: 0,
        verify_ssl: false
      )
      stripped_url_response_length = response.body.length

      if stripped_url_response_length == orig_url_response_length
        web_cache_deception_url = "#{stripped_target_url.to_s.chomp('/')}/wcd.#{payload}"
        response = browser_obj.execute(
          method: :get,
          url: web_cache_deception_url,
          user_agent: 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36',
          max_redirects: 0,
          verify_ssl: false
        )
        wcd_url_response_length = response.body.length

        if stripped_url_response_length == wcd_url_response_length
          puts "\n#{@dark_red}Alert! Potential Candidate: #{web_cache_deception_url}#{@end_of_color}\n"
          return "Alert! Potential Candidate: #{web_cache_deception_url}"
        else
          print "#{@yellow}.#{@end_of_color}"
          return "Response Length Mismatch: HTTP #{response.code} | Strip Len: #{stripped_url_response_length} | WCD Len: #{wcd_url_response_length} | WCD: #{web_cache_deception_url}"
        end

      else
        print "#{@yellow}.#{@end_of_color}"
        return "Response Length Mismatch: HTTP #{response.code} | Orig Len: #{orig_url_response_length} | WCD Len: #{stripped_url_response_length} | WCD: #{web_cache_deception_url}"
      end
    else
      print "#{@yellow}.#{@end_of_color}"
      return "HTTP #{response.code}: #{web_cache_deception_url}"
    end
  rescue RestClient::InternalServerError => ise
    puts "\n#{@dark_red}#{ise}: #{web_cache_deception_url}#{@end_of_color}\n"
    return "Alert! #{ise}: #{web_cache_deception_url}"
  rescue RestClient::ExceptionWithResponse => ewr
    print "#{@yellow}.#{@end_of_color}"
    return "#{ewr}: #{web_cache_deception_url}"
  rescue => e
    raise e
  end

  if proxy
    if with_tor
      browser_obj = CSI::Plugins::TransparentBrowser.open(
        browser_type: :rest,
        proxy: proxy,
        with_tor: true
      )::Request
    else
      browser_obj = CSI::Plugins::TransparentBrowser.open(
        browser_type: :rest,
        proxy: proxy
      )::Request
    end
  else
    browser_obj = CSI::Plugins::TransparentBrowser.open(browser_type: :rest)::Request
  end

  if spider
    if File.exist?(spider_results)
      puts "#{@dark_red}Using Existing Spider Results: #{spider_results}#{@end_of_color}"
    else
      puts "#{@dark_red}Spidering Target FQDN: #{target_url}#{@end_of_color}"
      File.open(spider_results, 'w') do |f|
        Anemone.crawl(target_url) do |anemone|
          anemone.on_every_page do |page|
            puts "#{@yellow}Discovered: #{page.url}#{@end_of_color}"
            f.puts(page.url)
          end
        end
      end
    end
  end

  web_cache_deception_payload_arr = %w(
    aif aiff au avi bin bmp cab carb cct cdf class css doc dcr dtd gcf gff gif grv hdml hqx ico ini jpeg jpg js mov mp3 mp4 nc pct ppc pws swa swf txt vbs w32 wav wbmp wml wmlc wmls wmlsc xsd zip
  )
  
  File.open(output_results, 'w') do |f|
    web_cache_deception_payload_arr.each do |payload|
      if spider
        File.readlines(spider_results).uniq.each do |this_page|
          http_result = get_web_cache_deception(browser_obj: browser_obj, target_url: this_page, payload: payload)
          f.puts http_result
        end
      else
        http_result = get_web_cache_deception(browser_obj: browser_obj, target_url: target_url, payload: payload)
        f.puts http_result
      end
    end
  end
rescue => e
  raise e
ensure
  browser_obj = CSI::Plugins::TransparentBrowser.close(browser_obj: browser_obj) unless browser_obj.nil?
end
